package com.greedy.section01.extend;

public class Application {

	public static void main(String[] args) {
		
		/* 상속(inheritance)은 현실 세계의 상속과 비슷한 개념이다.
		 * 부모가 가지고 있는 재산(자바에서는 클래스가 가지는 멤버)을 자식이 물려받는다는 의미이다.
		 * 클래스 또한 부모클래스와 자식클래스로 역할을 나누어서 부모가 가지는 멤버를 자식이 물려 받아
		 * 자신의 멤버인 것 처럼 사용할 수 잇도록 만든 기술이다.
		 * 
		 * 하지만 단순히 물려받는 개념보다 조금 더 나아간다면
		 * 자바에서의 상속은 부모 클래스의 확장(extend)의 개념을 가진다.
		 * 물려받아서 자신의 것  처럼 사용하는 것 뿐 아니라 추가적인 멤버도 작성이 가능하기 때문이다.
		 * 특히 메소드 재정의(overriding)라는 기술을 이용해서 부모가 가진 메소드를 재정의 하는 것도 가능해진다.
		 * 
		 * 메소드 재정의(overriding)이란 부모가 가지는 메소드 선언부를 그대로 사용하면서
		 * 자식클래스가 정의한 메소드대로 동작하도록 구현 몸체 부분을 새롭게 다시 작성하는 기술이다.
		 * 메소드 재정의를 하면 메소드를 호출할 시 재정의한 메소드가 우선적으로 동작하게 된다. (동적바인딩 - 다형성에서 다룰 예정)
		 * 
		 *
		 * 
		 * 상속의 장점
		 * 1. 새로운 클래스를 작성할 시 기존에 작성한 클래스를 재사용할 수 있다.
		 * 	1-1. 재사용 시 생산성을 크게 향상시킬 수 있다. (새롭게 작성하는 것 보다 빠르다.)
		 *  1-2. 공통적으로 사용하는 코드가 부모클래스에 존재하면 수정사항이 생길 시 부모 클래스만 수정해도 전체적으로 적용된다. (유지 보수성 증가)
		 * 2. 클래스간의 계층관계가 형성되며 다형성의 문법적인 토대가 된다.
		 * 
		 * 상속의 단점
		 * 1. 부모 클래스의 기능을 추가/변경할 시 자식클래스가 정상적으로 동작하는지에 대한 예측이 힘들다.
		 * 	    상속 구조가 복잡해 질 수록 그 영향에 대한 예측이 힘들며 이런 단점이 유지보수성을 증가한다는 장점과는 반대로
		 * 	    유지보수성에 악영향을 미친다.
		 * 
		 * 2. 또한 부모 클래스의 변경이 쉽지 않다. 자식 클래스에서 중요하게 사용하는 기능인 경우
		 * 	    부모클래스를 변경할 시 자식클래스에 모두 영향을 줄 수 있다.
		 * 
		 * 3. 부모 클래스에서는 의미있던 기능이 자식클래스에서는 무의미할 수 있다. (불필요한 기능이 추가됨)
		 * */
		
		
		/* 객체 지향 설계 관점에서 바라보는 상속
		 * 모든 객체는 자신이 수신한 메세지에 대해 응답을 해야 하는 책임을 가지며, 그 책임의 규모는 적절해야 한다.
		 * 적절한 책임을 가진 객체들이 서로 협력(메세지 수신과 응답)을 통해 프로그램이 동작하는 것이 객체지향 프로그램이다.
		 * 
		 * 적절한 책임을 수행하는 객체 또한 그 객체만 수행할 수 있는 기능보다는, 역할의 관점으로 바라봐야 한다.
		 * 역할이란 동일한 동작을 수행하는 것을 정의한 것이며, 대체 가능성을 의미한다.
		 * 
		 * 부모 클래스를 추상화하는 경우에는 역할의 관점으로 바라봐야 한다.
		 * 그래야 자식클래스로 생성한 객체들이 서로 역할을 수행해가며 유연한 코드를 작성할 수 있게 된다.
		 * 
		 * 동일한 역할을 수행하는 모든 객체는 동일한 메세지를 수신하지만, 객체별로 그 메세지를 응답하는 방식은 다룰 수 있다.(다형성)
		 * */
		
		
		Car car = new Car();
		
		car.soundHorn();
		car.run();
		car.soundHorn();
		car.stop();
		car.soundHorn();
		
		/* 소방차는 자동차이다. 하지만 모든 자동차들이 소방차는 아니다.
		 * FireCar is a Car (o) / Car is a FireCar (x)
		 * 레이싱카는 자동차이다. 하지만 모든 레이싱카는 자동차는 아니다.
		 * RacingCar is a Car (o) / RacingCar is a FireCar (x)
		 * */
		
		FireCar fireCar = new FireCar(); // fireCar라는 객체가 만들어짐. 컴파일러가 super생성자가 호출시킴. 자식클래스가 호출이 되면 부모 클래스도 호출이 됨.
		
		//상속받은거여서 부모클래스에 있는 멤버가 호출됨. 부모클래스에 있는 기능을 내 꺼 처럼 쓸 수 있음
		fireCar.soundHorn();
		fireCar.run();
		fireCar.soundHorn();
		fireCar.stop();
		fireCar.soundHorn();
		
		//단 private 속성과 기능은 접근 불가
//		fireCar.runningState();
//		fireCar.isRunning();
		
		fireCar.sprayWater();
		
		RacingCar racingCar = new RacingCar();
	
		racingCar.soundHorn();
		racingCar.run();
		racingCar.soundHorn();		// 상속의 단점은 불필요한 메소드를 가지고 있다. ex) 레이싱 카는 빵빵거리지 않는데 상속으로 인해 어쩔 수 없이 가지고 있다.
		racingCar.stop();
		racingCar.soundHorn();
	
	}

}
